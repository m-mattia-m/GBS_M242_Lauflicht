;********************************************************************************
; P R O G R A M M    Vorlage
;********************************************************************************
; Source-File:      	Lauflicht.a51
; Autor:            	Kay Wild, Christophe Damas, Mattia Müggler
; Datum:            	05.06.2021
; Version:            	1.0
; Beschreibung:        	Lauflicht
; Eingaben:            	8 Schalter S0 bis S7
; Ausgaben:            	8 LEDs PA0 bis PA7
;********************************************************************************
     
$TITLE (Lauflicht)
$NOLIST
$NOMOD51
$INCLUDE (C8051F020.h)                		;hier werden alle Bezeichnungen definiert
$LIST
 
NAME Lauflicht
 
;----- Deklarationen
input    equ        P2                    	;P3 8 Eingänge
output   equ        P3                   	;P2 8 Ausgänge
llStatus	data	20h						; ll -> LaufLichtStatus
dStatus		data	21h						; directionStatus -> welche richtung zuletzt
fast		data	22h						; deklariert geschwindigkeit
 
;----- Intitialisierung
        ORG        0000h                	;Startadresse
        jmp        init
 
        ORG        	0100h                	;Programmanfang
init:  	mov        	WDTCN,#0DEh
        mov        	WDTCN,#0ADh            	;disable Watchdog
       	mov        	P2MDOUT,#0FFh        	;P2 8 Ausgänge push/pull
        mov        	P3MDOUT,#000h        	;P3 8 Eingänge
        mov        	XBR2,#040h            	;enable crossbar (Koppelfeld)
 
;------ Hauptprogramm
main:   mov        output,#00h            	;LEDs dunkel schalten
		mov			input, #00h
		mov       A,#0h
 
loop:                   	;Schalter einlesen 
        jnb		input.2, fastFalse
		mov		fast, #6h					; -> wert für Wait anpassen	wenn schnell
		jmp		fastEnd
fastFalse:
		mov fast, #60h;	 					; -> wert für Wait anpassen wenn langsam
fastEnd:	
   
        jb      input.3, CBitBack ;Endlosschleife
		jmp		CBit


lightsUp: 
		CALL 	CMPR
		jnb		input.4, lightsUpTrue
		rl		A
		add 	A, #1h

lightsUpTrue:
		rl		A
		add 	A, #1h
		mov		output, A
		CALL 	wait
		jmp		loop

lightsDown:	
		CALL 	CMPR
		jnb		input.4, lightsDownTrue
		rl		A
		subb 	A, #1h

lightsDownTrue:
		rl		A
		subb 	A, #1h
		mov		output, A
		CALL 	wait
		jmp		loop


lightsUpBack: 
		CALL 	CMPR
		jnb		input.4, lightsUpBackTrue
		add 	A, #1h
		rr		A

lightsUpBackTrue:
		add 	A, #1h
		rr		A
		mov		output, A
		CALL 	wait
		jmp		loop

lightsDownBack:	
		CALL 	CMPR
		jnb		input.4, lightsDownBackTrue
		subb 	A, #1h 
		rr		A

lightsDownBackTrue:
		subb 	A, #1h 
		rr		A
		mov		output, A
		CALL 	wait
		jmp		loop
 
; überprüft ob stop oder pasue gedrückt wurde
CMPR:           
        JB        	input.0, CMPR
        JB        	input.1, reset
        RET

CBit:	jb		dStatus.0, CBitTrue
		mov 	A, #0h
		mov		dStatus, #1h

CBitTrue:	
		mov		llStatus, A
		jb		llStatus.7, lightsDown
		jmp 	lightsUp 

CBitBack:	jnb dStatus.0, CBitBackTrue
			mov 	A, #0h
			mov		dStatus, #0h
			

CBitBackTrue:
			mov llStatus, A
			jb llStatus.0, lightsDownBack
			jmp	lightsUpBack	 

; start delay

wait:   mov R5, #0FFh		   
wait1:  mov R6, #0FFh
wait2:  mov R7, #05h
wait3:	mov R4, fast			; bei Mesa wait 4 wieder entfernen
wait4:  djnz R4, wait4
		djnz R7, wait3
        djnz R6, wait2
        djnz R5, wait1
        ret


reset:   mov        output,#00h 
		mov	A, #0h
		jmp loop
        END